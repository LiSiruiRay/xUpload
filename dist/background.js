import{g as _,a as L,i as v,b,c as J,s as X,d as S,l as i,t as H,v as I,e as Y,r as g,f as Z,h as O,j as q,k as y,m as ee,n as te,o as ae,u as oe,p as ne,q as $,w as re,x as ce,y as se,z as ie,A as C}from"./workflow.js";const de="https://generativelanguage.googleapis.com/v1beta/models/text-embedding-004:embedContent",le="https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent";async function R(e,t){const a=await fetch(`${de}?key=${t}`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({content:{parts:[{text:e.slice(0,8e3)}]}})});if(!a.ok){const c=await a.text();throw new Error(`Gemini embedding error ${a.status}: ${c}`)}return(await a.json()).embedding.values}async function he(e,t,a=10,o){const c=[];for(let s=0;s<e.length;s+=a){const l=e.slice(s,s+a),h=await Promise.all(l.map(d=>R(d,t)));c.push(...h),o==null||o(Math.min(s+a,e.length),e.length),s+a<e.length&&await new Promise(d=>setTimeout(d,200))}return c}async function ue(e,t,a){var l,h,d,r,p;const o=await fetch(`${le}?key=${a}`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({contents:[{parts:[{inlineData:{mimeType:"image/png",data:e}},{text:`You are analyzing a webpage screenshot showing a file upload area. The surrounding text context is: "${t.slice(0,500)}"

Describe in 2-3 sentences what type of file this upload field is asking the user to provide. Be specific about the document type (e.g., passport, resume, transcript, photo ID, tax form, etc.). Focus on keywords that would help match against file names and content.`}]}],generationConfig:{maxOutputTokens:200,temperature:.2}})});if(!o.ok){const m=await o.text();throw new Error(`Gemini VLM error ${o.status}: ${m}`)}return((p=(r=(d=(h=(l=(await o.json()).candidates)==null?void 0:l[0])==null?void 0:h.content)==null?void 0:d.parts)==null?void 0:r[0])==null?void 0:p.text)||""}async function V(){if(b()>0)return;const e=await L();if(e){v(e),console.log("[xUpload] Vocab loaded from IndexedDB:",b(),"terms");return}return new Promise(t=>{chrome.storage.local.get("vocab",a=>{a.vocab?(v(a.vocab),console.log("[xUpload] Vocab loaded from chrome.storage:",b(),"terms"),$(a.vocab).catch(()=>{})):console.warn("[xUpload] No vocab found."),t()})})}V();chrome.runtime.onMessage.addListener((e,t,a)=>{if(e.type==="MATCH_REQUEST")return E(e).then(a),!0;if(e.type==="GET_FILE")return ye(e.id).then(a),!0;if(e.type==="GET_INDEX_COUNT")return _().then(o=>a({count:o})),!0;if(e.type==="BUILD_INDEX")return fe(e.files,e.workflowId).then(a),!0;if(e.type==="VOCAB_UPDATED")return(async()=>{const o=await L();o?(v(o),console.log("[xUpload] Vocab reloaded from IndexedDB:",b(),"terms")):chrome.storage.local.get("vocab",c=>{c.vocab&&(v(c.vocab),console.log("[xUpload] Vocab reloaded from chrome.storage:",b(),"terms"))}),a({ok:!0})})(),!0;if(e.type==="TRACK_UPLOAD"){const o=e.entry;return J(o).then(()=>{a({ok:!0})}).catch(c=>{console.error("[xUpload] Failed to track upload:",c),a({ok:!1})}),!0}if(e.type==="MATCH_REQUEST_ENHANCED")return ge(e).then(a),!0;if(e.type==="CAPTURE_TAB")return chrome.tabs.captureVisibleTab({format:"png"},o=>{if(chrome.runtime.lastError){a({error:chrome.runtime.lastError.message});return}const c=(o==null?void 0:o.replace(/^data:image\/\w+;base64,/,""))||"";a({base64:c})}),!0;if(e.type==="SAVE_USED_PATH")return X(e.host,e.filePath).then(()=>a({ok:!0})).catch(()=>a({ok:!1})),!0;if(e.type==="RESCAN_CONFIG_UPDATED")return T().then(()=>a({ok:!0})),!0;if(e.type==="CLEAR_SCANNED_DATA")return be(e).then(a),!0});function pe(e,t){const a=new Set(C(e.replace(/[/\\._-]/g," "))),o=new Set(C(t));if(a.size===0||o.size===0)return 0;let c=0;for(const l of a)o.has(l)&&c++;const s=Math.min(a.size,o.size);return c/s}function me(e,t){const a=new Set(C(e)),o=new Set(C(t));if(a.size===0||o.size===0)return 0;let c=0;for(const l of o)a.has(l)&&c++;const s=Math.min(a.size,o.size);return c/s}async function E(e){const t=e.workflowId||S("match-bg"),a=new Set;i(t,"match.start",{contextPreview:e.context.slice(0,140),accept:e.accept||"(none)",pageUrl:e.pageUrl||"(none)"});try{a.add("background.ensureVocab"),await V();const o=H(e.context),c=I(o);i(t,"service.tfidf.vectorize",{queryTokenCount:o.length,queryVectorSize:c.length}),a.add("vectordb.search");const s=c.length>0?await Y(c,15,e.accept):[],l=s.length>0?Math.max(...s.map(n=>n.score)):0,h=l>.05;i(t,"service.vectordb.search.done",{candidateCount:s.length,maxTfidf:g(l),tfidfUseful:h});let d=s;h||(a.add("vectordb.getAll"),d=(await Z()).map(u=>({record:u,score:0})),i(t,"ranking.fallback.path_content",{reason:"tfidf_low_signal",maxTfidf:g(l),fullCandidateCount:d.length}));let r="";if(e.pageUrl)try{r=new URL(e.pageUrl).hostname}catch{r=""}let p=[],m=[];r&&(a.add("vectordb.getHistoryByHost"),a.add("vectordb.getUsedPaths"),p=await O(r),m=await q(r),i(t,"service.history.lookup.done",{host:r,historyRows:p.length,memorizedPaths:m.length}));const G=new Set(m),U=new Map;for(const n of p){const u=U.get(n.fileId);u?(u.count++,u.lastTs=Math.max(u.lastTs,n.timestamp)):U.set(n.fileId,{count:1,lastTs:n.timestamp})}const W=24*60*60*1e3,K=Date.now(),x=d.map(n=>{const u=n.score;let w=0,D=0;const M=U.get(n.record.id);if(M){D=M.count;const Q=(K-M.lastTs)/W;w=Math.max(.1,1-Q/90)}const P=pe(n.record.path,e.context),B=me(n.record.textPreview,e.context),z=G.has(n.record.path)?1:0,N=w>0,f=h?N?{tfidf:.42,history:.28,path:.14,content:.08,pathMemory:.08}:{tfidf:.56,history:0,path:.22,content:.14,pathMemory:.08}:N?{tfidf:0,history:.36,path:.3,content:.2,pathMemory:.14}:{tfidf:0,history:0,path:.44,content:.42,pathMemory:.14},j=u*f.tfidf+w*f.history+P*f.path+B*f.content+z*f.pathMemory;return{...n,score:j,historyCount:D,debug:{tfidfScore:u,historyBoost:w,pathNameScore:P,contentOverlap:B,pathMemoryBoost:z,weights:f}}});x.sort((n,u)=>u.score-n.score);const k=x.slice(0,5).filter(n=>n.score>0);return i(t,"ranking.breakdown.top_candidates",x.slice(0,10).map((n,u)=>({rank:u+1,file:n.record.name,path:n.record.path,finalScore:g(n.score),tfidfScore:g(n.debug.tfidfScore),historyBoost:g(n.debug.historyBoost),pathNameScore:g(n.debug.pathNameScore),contentOverlap:g(n.debug.contentOverlap),pathMemoryBoost:n.debug.pathMemoryBoost,historyCount:n.historyCount,weights:n.debug.weights}))),i(t,"match.services_called",Array.from(a)),i(t,"match.done",{candidateCount:x.length,returnedCount:k.length,results:k.map(n=>`${n.record.name} (${Math.round(n.score*100)}%)`)}),{type:"MATCH_RESPONSE",workflowId:t,results:k.map(n=>({id:n.record.id,name:n.record.name,path:n.record.path,type:n.record.type,score:n.score,historyCount:n.historyCount}))}}catch(o){throw y(t,"match.failed",o),o}}async function F(){return new Promise(e=>{chrome.storage.local.get("xupload_config",t=>{e(t.xupload_config||{apiKey:"",mode:"tfidf"})})})}async function ge(e){const t=e.workflowId||S("match-enhanced-bg"),a=new Set(["chrome.storage.local.get:xupload_config"]);i(t,"match.enhanced.start",{mode:e.mode,hasScreenshot:!!e.screenshotBase64,contextPreview:e.context.slice(0,140),accept:e.accept||"(none)"});const o=await F();if(!o.apiKey)return i(t,"match.enhanced.fallback",{reason:"missing_api_key"}),E({type:"MATCH_REQUEST",context:e.context,accept:e.accept,pageUrl:e.pageUrl,workflowId:t});let c=e.context;if(e.mode==="vlm"&&e.screenshotBase64)try{a.add("gemini.describeWithVLM"),i(t,"service.gemini.describeWithVLM.start");const s=await ue(e.screenshotBase64,e.context,o.apiKey);i(t,"service.gemini.describeWithVLM.done",{descriptionPreview:s.slice(0,160)}),c=`${s} ${e.context}`}catch(s){y(t,"service.gemini.describeWithVLM.failed",s)}try{a.add("gemini.getEmbedding"),i(t,"service.gemini.getEmbedding.start");const s=await R(c,o.apiKey);a.add("vectordb.denseSearch");const l=await ee(s,5,e.accept);if(i(t,"service.vectordb.denseSearch.done",{queryVectorSize:s.length,candidateCount:l.length}),l.length===0)return i(t,"match.enhanced.fallback",{reason:"dense_no_results"}),E({type:"MATCH_REQUEST",context:e.context,accept:e.accept,pageUrl:e.pageUrl,workflowId:t});let h=[];if(e.pageUrl)try{const r=new URL(e.pageUrl).hostname;a.add("vectordb.getHistoryByHost"),h=await O(r)}catch{}const d=new Map;for(const r of h)d.set(r.fileId,(d.get(r.fileId)||0)+1);return i(t,"match.enhanced.services_called",Array.from(a)),i(t,"match.enhanced.done",{returnedCount:l.length,top:l.map(r=>`${r.record.name} (${Math.round(r.score*100)}%)`)}),{type:"MATCH_RESPONSE",workflowId:t,results:l.map(r=>({id:r.record.id,name:r.record.name,path:r.record.path,type:r.record.type,score:r.score,historyCount:d.get(r.record.id)||0}))}}catch(s){return y(t,"match.enhanced.failed",s),E({type:"MATCH_REQUEST",context:e.context,accept:e.accept,pageUrl:e.pageUrl,workflowId:t})}}async function fe(e,t=S("scan-bg")){const a=new Set(["embeddings.tokenize","embeddings.buildVocabulary","vectordb.clearAll","vectordb.upsert","vectordb.saveVocab","chrome.storage.local.set:vocab","vectordb.getCount"]);i(t,"scan.background.start",{fileCount:e.length,mode:"full"});try{const o=e.map(d=>H(d.text));te(o),i(t,"scan.phase.tfidf.done",{tokenizedFiles:o.length}),await ae(),i(t,"service.vectordb.clearAll.done");const c=await F();a.add("chrome.storage.local.get:xupload_config");let s=new Array(e.length).fill(void 0);if(c.apiKey&&c.mode!=="tfidf"){a.add("gemini.batchEmbed"),i(t,"service.gemini.batchEmbed.start",{fileCount:e.length,mode:c.mode});try{const d=e.map(p=>p.text.slice(0,2e3)),r=await he(d,c.apiKey,10,(p,m)=>{i(t,"service.gemini.batchEmbed.progress",{done:p,total:m})});s=r,i(t,"service.gemini.batchEmbed.done",{vectorCount:r.length})}catch(d){y(t,"service.gemini.batchEmbed.failed",d)}}for(let d=0;d<e.length;d++){const r=e[d],p=I(o[d]);await oe({id:r.path,name:r.name,path:r.path,type:r.type,size:r.size,lastModified:r.lastModified,vector:p,denseVector:s[d],textPreview:r.text.slice(0,500)})}i(t,"service.vectordb.upsert.done",{upserted:e.length});const l=ne();await $(l),await new Promise(d=>{chrome.storage.local.set({vocab:l},d)}),i(t,"service.vocab.persist.done",{termCount:l.terms.length});const h=await _();return i(t,"scan.background.services_called",Array.from(a)),i(t,"scan.background.done",{indexedCount:h}),{ok:!0,count:h,workflowId:t}}catch(o){return y(t,"scan.background.failed",o),{ok:!1,error:(o==null?void 0:o.message)||String(o),workflowId:t}}}async function ye(e){console.log("[xUpload] GET_FILE:",e);const t=await re(e);return t?(console.log("[xUpload] Sending:",t.name),t):{error:"Permission expired. Click the xUpload extension icon and use 'Rescan folder' to re-authorize file access."}}async function be(e){const t=e.workflowId||S("clear-bg");i(t,"clear.start");try{await ce(),await new Promise(o=>{chrome.storage.local.remove(["vocab"],()=>o())}),v({terms:[],idf:[]});const a=await _();return i(t,"clear.done",{remainingIndexedCount:a}),{ok:!0,count:a,workflowId:t}}catch(a){return y(t,"clear.failed",a),{ok:!1,error:(a==null?void 0:a.message)||String(a),workflowId:t}}}const A="xupload-rescan";async function T(){await chrome.alarms.clear(A);const e=await se();e.autoRescanEnabled&&e.rescanIntervalMin>0?(chrome.alarms.create(A,{periodInMinutes:e.rescanIntervalMin}),console.log(`[xUpload] Rescan alarm set: every ${e.rescanIntervalMin} min`)):console.log("[xUpload] Auto-rescan disabled")}chrome.alarms.onAlarm.addListener(async e=>{if(e.name!==A)return;console.log("[xUpload] Auto-rescan alarm fired");const t=await ie();if(!t){console.log("[xUpload] No directory handle, skipping auto-rescan");return}try{if(await t.queryPermission({mode:"read"})!=="granted"){console.log("[xUpload] Directory permission not granted, skipping auto-rescan"),chrome.action.setBadgeText({text:"!"}),chrome.action.setBadgeBackgroundColor({color:"#ea4335"});return}chrome.action.setBadgeText({text:""}),console.log("[xUpload] Auto-rescan: directory handle valid, notifying tabs")}catch(a){console.error("[xUpload] Auto-rescan error:",a)}});chrome.runtime.onStartup.addListener(()=>{console.log("[xUpload] Extension started"),V(),T()});chrome.runtime.onInstalled.addListener(()=>{console.log("[xUpload] Extension installed/updated"),T()});T();
